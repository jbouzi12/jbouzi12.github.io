<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css"></link>
    <link href="http://fonts.googleapis.com/css?family=Lato:300" rel="stylesheet" type="text/css"></link>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../stylesheets/normalize.css" type="text/css"></link>
    <title>Week8 Technical</title>
  </head>
  <body>
    <header class = "header-wrapper">
      <div id = "container">
        <a href="http://jbouzi12.github.io/"class = "logo">
          <h1 id="my-name">Jensen Bouzi</h1>
          <h2 id="sub-name">Aspiring Developer</h2>
        </a>
        <nav>
          <ul>
            <li><a href="http://jbouzi12.github.io/">Home</a></li>
            <li><a href="../about-me/about-me.html">About Me</a></li>
            <li><a href="../projects/projects-page.html">Projects</a></li>
            <li><a href="../blog-posts/contact-page.html">Contact</a></li>
            <li id = "blog-bar"><a href="cultural_blog_index.html">Blog</a>
              <ul id = "submenu">
                <li class = "nav-text"><a href="../blog-posts/cultural_blog_index.html">Cultural Blog</a></li>
                <li class = "nav-text"><a href="technical_blog_index.html">Technical Blog</a></li></li>
          </ul>
        </nav>
      </div>
    </header>

    <section class = "blog-title">
      <div class="clear">
        <h5><!-- CLEARANCE SPACE --></h5>
      </div>
      <div class = "title-box" id = "container">
        <h1 class = "title-text1">THE CREAM | THE CROP</h1>
      </div>
    </section>

    <section id="archive">
      <div class="container">
        <div id = "post">
          <h1>Big O Complexity and Notation</h1>

          <p>How efficient is a piece of code or an algorithm? This is an important question for developers, and one that I&apos;ve been contemplating for the past few weeks at Dev Bootcamp. Many factors affect efficiency, but there are two in particular that I wish to focus on: performance and complexity. Performance deals with how much time/memory/disk etc. is used when a program is run, and depends on the machine, compiler, etc. in addition to the code. Complexity involves what occurs as the size of the problem being solved gets longer. It is important to note that complexity affects performance, but not the other way around. These two concepts are vital for discussing <strong>Big O Notation</strong>. </p>

          <p>When considering the complexity of a method, we are really talking about how the number of operations (hence &apos;O&apos;) relates to the problem size. Some methods perform the same number of operations each time they are called (e.g. #size method) while others perform different numbers of operations depending on the value of a parameter. A good way to understand this is that the time required by a method to execute is proportional to the number of basic operations that it performs. So if the problem size doubles, will the number of operations remain the same? double? or increase by another amount? Thus for a method&apos;s complexity, what is important is this question: what is the most operations that may be performed for a given problem size?</p>

          <p>Complexity is expressed by using big-O notation. Also referred to as Landau&apos;s symbol, is used in complexity theory, computer science, and mathematics to describe how fast a method grows or declines (asymptotic behavior). It was invented by Edmund Landau, the German number theoretician; the letter O is used because the rate of growth of a function is also called its <strong>order</strong>. The following image illustrates the classes of common functions that you come across when analyzing algorithms:</p>

          <img src="../imgs/function_class_img.png">

          <p>For instance, when looking at a constant-time method, we say that it is &apos;order 1&apos;: O(1). In the chart, the slower growing functiosn are listed first and c is an arbitrary constant. O(n!) is the worst complexity because it requires many operations(hundreds!) just for a few elements while O(1) is the best complexity, and only requires a constant number of operations for any number of elements. There are many other important aspects of big-O notation that are beyond the scope of this introductory post, but these resources are a great way to get your feet wet, the third of which is a cool cheat sheet:<p>

          <a href=”http://bigocheatsheet.com/”>CheatSheet, </a>
          <a href=”http://web.mit.edu/16.070/www/lecture/big_o.pdf”>MIT Introduction, </a>
          <a href=”http://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html>Wisc.edu</a>
          <hr width="100%"></hr><br></br>
          <p id = "date">Jensen Bouzi September 26, 2014</p>
        </div>
      </div>
    </section>

    <footer>
      <h4>
        <span>Jensen Bouzi &copy; 2014  | Follow me on:</span>
        <a href="https://www.facebook.com/jbouzi"><img src="../imgs/FB-f-Logo__white_512.png"/></a>
        <a href="http://www.linkedin.com/in/jensenbouzi/"><img src="../imgs/linkedin.png"/></a>
        <a href="https://github.com/jbouzi12"><img src="../imgs/Octocat.png"/></a>
        <a href="http://instagram.com/immerse_12"><img src="../imgs/Instagram_Icon_Large.png"/></a>
        <a href="https://twitter.com/jensenbouzi"><img src="../imgs/Twitter_logo_blue.png"/></a>
        <a href="https://plus.google.com/u/0/118433877871429485489/posts?cfem=1"><img src="../imgs/Gplus.png"/></a>
        </h4>
    </footer>
  </body>
</html>